9. Split de pedido
POST /api/orders/:id/splitPermiso: orders.updateBody: SplitOrderByItemsDto
	‚Ä¢	Duplica los √≠tems seleccionados a un nuevo pedido
	‚Ä¢	Incluye combos
	‚Ä¢	El nuevo pedido hereda:
	‚Ä¢	serviceType
	‚Ä¢	tableId
	‚Ä¢	covers
	‚Ä¢	source
	‚Ä¢	Se pueden sobrescribir
	‚Ä¢	Marca acceptedAt de inmediato
Qu√© hace el controller (exacto)
	1	const orderId = ensureNumericId(req.params.id);
	2	const dto = SplitOrderByItemsDto.parse(req.body);
	3	saca servedByUserId de req.auth.userId ‚Üí si no hay ‚Üí 401
	4	llama:this.splitOrderByItemsUC.exec(orderId, {
	5	  ...dto,
	6	  servedByUserId,
	7	});
	8	
	9	responde:{
	10	  "error": null,
	11	  "data": {
	12	    "newOrderId": 123,
	13	    "code": "A-2025-000123"
	14	  },
	15	  "message": "Order split"
	16	}
	17	con HTTP 201

DTO exacto (de orders.dto.ts)

export const SplitOrderByItemsDto = z.object({
  itemIds: z.array(z.number().int().positive()).min(1),
  // Puedes sobreescribir metadatos del pedido nuevo (opcionales)
  serviceType: ServiceTypeEnum.optional(),
  tableId: z.number().int().positive().nullable().optional(),
  note: z.string().optional(),
  covers: z.number().int().positive().optional()
});
Traducci√≥n:
	‚Ä¢	itemIds ‚úÖ obligatorio, al menos 1
	‚Ä¢	serviceType ‚ùì opcional ‚Üí si no lo mandas, usa el del pedido original
	‚Ä¢	tableId ‚ùì opcional ‚Üí puedes poner mesa nueva o null para que NO tenga
	‚Ä¢	note ‚ùì opcional ‚Üí nota del nuevo pedido
	‚Ä¢	covers ‚ùì opcional ‚Üí comensales del nuevo pedido

Lo M√ÅS importante de tu repo (esto es lo que lo hace especial)
En PrismaOrderRepository.splitOrderByItems(...) hace 5 pasos:
	1	Valida que todos los itemIds sean de ese pedido (sourceOrderId).Si hay uno que no‚Ä¶ ‚Üí "Todos los items deben pertenecer al mismo pedido"
	2	Expande combos:
	‚ó¶	si mandaste un padre ‚Üí mete todos sus hijos
	‚ó¶	si mandaste un hijo ‚Üí mete su padre y todos los hermanos
	3	Crea el pedido nuevo copiando del original:
	‚ó¶	status: "OPEN"
	‚ó¶	serviceType: input.serviceType ?? src.serviceType
	‚ó¶	source: src.source ?? "POS"
	‚ó¶	tableId: input.tableId ?? src.tableId ?? null
	‚ó¶	note: input.note ?? null
	‚ó¶	covers: input.covers ?? src.covers ?? null
	‚ó¶	servedByUserId: input.servedByUserId
	‚ó¶	acceptedAt: new Date()
	‚ó¶	code: generateOrderCode()
	4	Mueve esos items al nuevo pedido (updateMany ... data: { orderId: newOrder.id })
	5	Recalcula totales en los dos pedidos:
	‚ó¶	el original (porque le quitaste cosas)
	‚ó¶	el nuevo (porque le pusiste cosas)
y te regresa:

{ "newOrderId": ..., "code": "..." }
Listo üëå

CASOS üí•
1. Dividir un pedido de mesa en dos mesas
Pedido original: id = 45, DINE_IN, mesa 3Quiero pasar 2 platillos a la mesa 7
Request

{
  "itemIds": [101, 102],
  "tableId": 7
}
Qu√© pasa:
	‚Ä¢	crea NUEVO pedido:
	‚ó¶	status: OPEN
	‚ó¶	serviceType: DINE_IN (copiado)
	‚ó¶	tableId: 7 (lo que mandaste)
	‚ó¶	note: null
	‚ó¶	covers: los del original
	‚Ä¢	mueve los items 101 y 102 ah√≠
	‚Ä¢	recalcula los dos
Response

{
  "error": null,
  "data": {
    "newOrderId": 120,
    "code": "A-2025-000120"
  },
  "message": "Order split"
}

2. Dividir sin cambiar mesa (solo separar ticket)
Pedido original: mesa 3Solo quiero mandar estos items a ‚Äúotra cuenta‚Äù pero misma mesa.

{
  "itemIds": [101, 103]
}
(no mandas mesa)
‚Üí el repo hace:
	‚Ä¢	tableId: src.tableId (o sea, la misma 3)

3. Dividir y quitar mesa (p.ej. para cobrar en caja)

{
  "itemIds": [200, 201],
  "tableId": null,
  "note": "Cobro en caja"
}
‚Üí nuevo pedido nace sin mesa y con nota ‚ÄúCobro en caja‚Äù.

4. Dividir y cambiar serviceType (de DINE_IN a TAKEAWAY)
Esto es √∫til cuando alguien de la mesa dice ‚Äúese es para llevar‚Äù.

{
  "itemIds": [300],
  "serviceType": "TAKEAWAY",
  "note": "Para llevar"
}
‚Üí nuevo pedido:
	‚Ä¢	serviceType = TAKEAWAY
	‚Ä¢	tableId = null (porque no mandaste y TAKEAWAY no ocupa)
	‚Ä¢	note = ‚ÄúPara llevar‚Äù

5. Dividir un combo padre (manda SOLO el padre)
Sup√≥n que en el pedido hay un combo con itemId 400.

{
  "itemIds": [400]
}
El repo ve que 400 tiene hijos ‚Üí busca a todos sus hijos ‚Üí los mete tambi√©n ‚Üí se van JUNTOS al nuevo pedido.As√≠ no te queda el combo descuadrado.

6. Dividir un hijo de combo (manda SOLO el hijo)
Sup√≥n que el pap√° es 400 y el hijo que quieres mover es 402.

{
  "itemIds": [402]
}
El repo hace EXACTAMENTE esto:
	1	‚ÄúAh, este es hijo‚Äù
	2	trae a su padre
	3	trae a sus hermanos
	4	mete a TODOS juntos en el nuevo pedido
Resultado: nunca te quedas con un combo ‚Äúpartido‚Äù.

7. Dividir y poner covers distintos

{
  "itemIds": [501, 502],
  "covers": 1
}
‚Üí nuevo pedido con covers = 1‚Üí pedido origen se queda con sus covers originales.

8. Dividir con nota espec√≠fica (para cocina / caja)

{
  "itemIds": [601],
  "note": "Cliente paga por separado"
}

9. Intentar dividir sin items ‚Üí ERROR

{
  "itemIds": []
}
Respuesta:

{
  "error": {
    "code": 400,
    "details": "itemIds must contain at least 1 element(s)"
  },
  "data": null,
  "message": "Error splitting order"
}
(esto viene del Zod porque pusiste .min(1))

10. Intentar dividir items de 2 pedidos diferentes ‚Üí ERROR
Sup√≥n que mandas [101, 9999] y 9999 es de otro pedido.

{
  "itemIds": [101, 9999]
}
Respuesta (del repo):

{
  "error": {
    "code": 500,
    "details": "Todos los items deben pertenecer al mismo pedido"
  },
  "data": null,
  "message": "Error splitting order"
}

11. Intentar dividir con usuario no autenticado ‚Üí 401
(no tiene req.auth.userId)

{
  "itemIds": [101]
}
Respuesta:

{
  "error": {
    "code": 401,
    "details": null
  },
  "data": null,
  "message": "Unauthorized"
}
Porque el controller hace:

if (!servedByUserId) return fail(res, "Unauthorized", 401);

12. Dividir y mandar serviceType + tableId juntos

{
  "itemIds": [710, 711],
  "serviceType": "DINE_IN",
  "tableId": 12,
  "note": "Se cambiaron de mesa"
}
‚Üí v√°lido; el nuevo pedido nace como DINE_IN en mesa 12.

13. Pedido origen no existe ‚Üí ERROR
Si el :id no existe:
Request

POST /api/orders/99999/split
Body

{ "itemIds": [1] }
Response (del repo):

{
  "error": {
    "code": 500,
    "details": "Pedido origen no existe"
  },
  "data": null,
  "message": "Error splitting order"
}

Cosas que tu front TIENE que saber
	1	Este endpoint NO regresa el pedido nuevo completo, solo:{ "newOrderId": ..., "code": "..." }
	2	‚Üí si lo quieres completo haces luego:GET /api/orders/{{newOrderId}}
	3	
	4	Siempre recalcula los dos pedidos. O sea: en la pantalla de la mesa original te va a bajar el total.
	5	Nunca te deja combos ‚Äúrotos‚Äù: si mandas pap√° o hijo, mueve el combo entero (padre + hijos + hermanos).
	6	Puedes usarlo para ‚Äúpagar por separado‚Äù: divides, pagas el nuevo, dejas el viejo abierto.
	7	Se guarda qui√©n hizo el split (servedByUserId), lo cual est√° chido para auditor√≠a.

10. Notas funcionales clave
	‚Ä¢	Los totales siempre se recalculan ignorando √≠tems cancelados.
	‚Ä¢	Se respetan descuentos / impuestos / service fee ya guardados.
	‚Ä¢	prepEtaMinutes sirve para mostrar ETA en front / kiosko.
	‚Ä¢	source y externalRef diferencian interno vs plataforma.
	‚Ä¢	Con esto el front puede hacer todo el flujo:
	0.	creaci√≥n
	0.	agregar / editar √≠tems
	0.	KDS
	0.	cobros
	0.	cierre
	0.	listado con filtros

11. Glosario para el front
Permisos
	‚Ä¢	orders.read: puede listar y ver
	‚Ä¢	orders.create: puede crear
	‚Ä¢	orders.update: puede editar, pagar, mover estado
serviceType (tipo de servicio)
	‚Ä¢	DINE_IN: consumo en mesa
	‚Ä¢	TAKEAWAY: para llevar
	‚Ä¢	DELIVERY: a domicilio
source (canal)
	‚Ä¢	POS: pedido directo
	‚Ä¢	UBER, DIDI, RAPPI: plataformas externas
status del pedido
	‚Ä¢	DRAFT: borrador, no cocina
	‚Ä¢	OPEN: activo
	‚Ä¢	HOLD: en pausa
	‚Ä¢	CLOSED: cobrado y cerrado
	‚Ä¢	CANCELED: cancelado
OrderItem.status
	‚Ä¢	NEW
	‚Ä¢	IN_PROGRESS
	‚Ä¢	READY
	‚Ä¢	SERVED
	‚Ä¢	CANCELED
Timestamps
	‚Ä¢	acceptedAt: el pedido sali√≥ de borrador / cocina lo tom√≥
	‚Ä¢	readyAt: todos los √≠tems est√°n listos
	‚Ä¢	servedAt: todos servidos o cancelados
	‚Ä¢	closedAt: se cobr√≥
	‚Ä¢	canceledAt: se cancel√≥
Totales (centavos)
	‚Ä¢	subtotalCents: suma de renglones
	‚Ä¢	discountCents: descuentos
	‚Ä¢	serviceFeeCents: propina/fee fijo
	‚Ä¢	taxCents: impuestos
	‚Ä¢	totalCents: subtotal - descuento + service + tax
	‚Ä¢	paymentsTotalCents: suma de pagos
	‚Ä¢	paymentsTipCents: suma de propinas
Pagos (payments[])
	‚Ä¢	method: CASH | CARD | TRANSFER | OTHER
	‚Ä¢	amountCents
	‚Ä¢	tipCents
	‚Ä¢	paidAt
	‚Ä¢	note
Mesa
	‚Ä¢	tableId: id de la mesa
	‚Ä¢	table: { id, name } para mostrar ‚ÄúMesa 12‚Äù
	‚Ä¢	covers: n√∫mero de comensales
DTOs clave
	‚Ä¢	ListOrdersQueryDto: filtros del GET
	‚Ä¢	UpdateOrderMetaDto: para editar nota, mesa, cubiertos, ETA
	‚Ä¢	UpdateOrderStatusDto: para mover el pedido validando pagos

Si quieres, en la siguiente te lo bajo todav√≠a m√°s a ‚Äúdoc para front‚Äù (solo campos + ejemplo), pero as√≠ ya est√° ordenado y sin que se vea todo pegado.
