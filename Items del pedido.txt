7. √çtems del pedido

7.2 Actualizar √≠tem
PATCH /api/orders/items/:itemIdPermiso: orders.updateBody: UpdateOrderItemDto
Permite:
	‚Ä¢	cambiar quantity
	‚Ä¢	cambiar notes
	‚Ä¢	reemplazar modifiers
El backend:
	‚Ä¢	ajusta extras
	‚Ä¢	actualiza combos hijos
	‚Ä¢	recalcula totales

Casos:
O sea: solo puedes tocar estas 3 cosas:
	1	quantity ‚Üí cambiar cantidad
	2	notes ‚Üí cambiar nota del rengl√≥n
	3	replaceModifiers ‚Üí reemplazar TODOS los modifiers que ten√≠a el item por estos nuevos
No puedes:
	‚Ä¢	cambiar productId
	‚Ä¢	cambiar variantId
	‚Ä¢	cambiar price directo
	‚Ä¢	cambiar el estado del item (eso es otra ruta: PATCH /api/orders/items/:itemId/status)
	‚Ä¢	cambiar el pedido (eso ya lo hace internamente el repo cuando recalcula)
Qu√© hace el repo (esto es lo importante del zip)
En PrismaOrderRepository.updateItem(...) hace esto:
	1	Busca el item con:
	‚ó¶	product (para ver si es combo)
	‚ó¶	modifiers actuales
	‚ó¶	childItems
	2	Si mandaste replaceModifiers:
	‚ó¶	borra todos los modifiers actuales del item
	‚ó¶	busca las opciones que mandaste
	‚ó¶	crea los nuevos modifiers con su priceExtraCents y nameSnapshot
	‚ó¶	suma los extras (extrasTotalCents)
	3	Calcula:
	‚ó¶	newQty = body.quantity ?? current.quantity
	‚ó¶	totalUnit = basePriceCents + extras
	‚ó¶	totalPriceCents = totalUnit * newQty
	4	Actualiza el item con:
	‚ó¶	quantity
	‚ó¶	notes
	‚ó¶	extrasTotalCents
	‚ó¶	totalPriceCents
	5	Si el item es combo padre (tiene childItems):
	‚ó¶	escala las cantidades de los hijos para que sigan al pap√°
	6	Llama a recalcTotalsTx(...) ‚Üí recalcula los totales del pedido üëà
Listo. Ahora s√≠ vamos con TODOS los casos que tiene sentido mandar.

CASOS ‚úÖ
1. Cambiar solo la cantidad

{
  "quantity": 3
}
	‚Ä¢	Sube de lo que tenga (ej. 1) a 3
	‚Ä¢	Recalcula totalPriceCents
	‚Ä¢	Recalcula totales del pedido

2. Cambiar solo la nota

{
  "notes": "Sin cebolla, porfa"
}
	‚Ä¢	No toca quantity
	‚Ä¢	No toca modifiers
	‚Ä¢	√ötil cuando cocina quiere dejar aclaraci√≥n

3. Cambiar cantidad y nota

{
  "quantity": 2,
  "notes": "Para mesa 4"
}

4. Reemplazar todos los modifiers por estos

{
  "replaceModifiers": [
    { "optionId": 7 },
    { "optionId": 9, "quantity": 2 }
  ]
}
Esto hace exactamente:
	1	borra los modifiers que ten√≠a ese item
	2	crea solo estos 2
	3	suma sus extras
	4	recalcula el total del item
	5	recalcula el total del pedido

5. Quitar todos los modifiers
(esto es lo chido: se hace mandando un array vac√≠o üëá)

{
  "replaceModifiers": []
}
El repo:
	‚Ä¢	borra todos los modifiers
	‚Ä¢	extrasTotalCents = 0
	‚Ä¢	totalPriceCents = basePriceCents * quantity

6. Cambiar cantidad y reemplazar modifiers

{
  "quantity": 3,
  "replaceModifiers": [
    { "optionId": 10 }
  ]
}
	‚Ä¢	Sube cantidad a 3
	‚Ä¢	Borra modifiers viejos
	‚Ä¢	Mete el 10
	‚Ä¢	Recalcula total (base + extra) * 3
	‚Ä¢	Recalcula totales del pedido

7. Cambiar solo un modifier pero dejando los dem√°s
üëâ Esto NO se puede con esta ruta, porque el campo es replaceModifiers.Si lo mandas, reemplaza todos.O sea, si quieres ‚Äúagregar uno m√°s y dejar los otros‚Äù, tienes que:
	1	traer la lista actual
	2	sumarle el nuevo
	3	mandarla completa en replaceModifiers
Ejemplo:

{
  "replaceModifiers": [
    { "optionId": 5 },
    { "optionId": 6 },
    { "optionId": 9, "quantity": 2 }
  ]
}

8. Item que es combo padre ‚Üí cambiar cantidad

{
  "quantity": 2
}
Como en el repo se ve:
	‚Ä¢	ve que el item tiene childItems
	‚Ä¢	calcula cu√°nto tra√≠a cada hijo por cada 1 del pap√°
	‚Ä¢	los vuelve a escribir multiplicados por 2
üü£ Ejemplo:
	‚Ä¢	antes: combo padre qty=1, hijo papas qty=1
	‚Ä¢	PATCH padre a qty=2
	‚Ä¢	repo deja hijo papas en qty=2
	‚Ä¢	y recalcula totales

9. Item que es combo padre ‚Üí cambiar nota

{
  "notes": "Una coca sin hielo"
}
	‚Ä¢	Solo cambia la nota del padre
	‚Ä¢	Los hijos se quedan igual

10. Item que es combo padre ‚Üí reemplazar modifiers

{
  "replaceModifiers": [
    { "optionId": 21 }
  ]
}
	‚Ä¢	Solo reemplaza los modifiers del padre
	‚Ä¢	Los hijos no los toca
	‚Ä¢	Recalcula totales

11. Item que es combo hijo (o sea, le pegas al itemId del hijo)
Esto tambi√©n funciona, porque el repo hace findUnique por item. Si el item no tiene hijos, no escala nada.

{
  "quantity": 2,
  "notes": "Este va sin sal"
}

12. Cambiar nota y quitar modifiers

{
  "notes": "Muy picante",
  "replaceModifiers": []
}

13. Actualizar solo modifiers con cantidades

{
  "replaceModifiers": [
    { "optionId": 15, "quantity": 3 },
    { "optionId": 18, "quantity": 1 }
  ]
}
El repo busca esos optionId; si uno no existe, tira:

Modifier option 15 inv√°lido
y tu controller responde 500.

14. Body vac√≠o (para probar validaci√≥n)

{}
El Zod lo acepta porque todo es opcional, peeero el update no cambiar√° nada. Igual te responde:

{
  "error": null,
  "data": null,
  "message": "Updated"
}
(esto pasa as√≠ porque en el usecase solo pasa lo que lleg√≥)

15. quantity = 0 (esto NO te lo va a aceptar)

{
  "quantity": 0
}
Tu Zod pide int().positive(), as√≠ que te va a regresar 400:

{
  "error": {
    "code": 400,
    "details": "quantity must be greater than 0"
  },
  "data": null,
  "message": "Validation failed"
}

16. Modifier que no existe ‚Üí error

{
  "replaceModifiers": [
    { "optionId": 999999 }
  ]
}
Respuesta (del controller):

{
  "error": {
    "code": 500,
    "details": "Modifier option 999999 inv√°lido"
  },
  "data": null,
  "message": "Error updating order item"
}
(El 500 es porque el repo lanz√≥ error directo.)

17. Cambiar cantidad de combo padre de 3 ‚Üí 1 (baja hijos)

{
  "quantity": 1
}
El repo calcula:
	‚Ä¢	antes: padre=3, hijo=3
	‚Ä¢	ahora: padre=1 ‚Üí hijo=1

7.3 Cambiar estado de un √≠tem
PATCH /api/orders/items/:itemId/statusPermiso: orders.updateBody: UpdateOrderItemStatusDto
Flujo permitido:
	‚Ä¢	NEW ‚Üí IN_PROGRESS ‚Üí READY ‚Üí SERVED
	‚Ä¢	o CANCELED en cualquier punto
Reglas:
	‚Ä¢	si todos los √≠tems quedan READY/SERVED ‚Üí se marca readyAt
	‚Ä¢	si todos quedan SERVED ‚Üí se marca servedAt
	‚Ä¢	si hay cancelaciones ‚Üí se recalculan totales
Casos:
El patr√≥n es igualito al de la orden, pero a nivel item:
	1	Lee :itemId y lo fuerza a n√∫mero.
	2	Valida el body con un Zod tipo:{
	3	  status: z.enum(["NEW","IN_PROGRESS","READY","SERVED","CANCELED"]),
	4	  reason?: z.string().optional()
	5	}
	6	
	7	Llama al repo: orderRepository.updateItemStatus(itemId, dto)
	8	El repo:
	‚ó¶	actualiza solo ese rengl√≥n
	‚ó¶	si el rengl√≥n es combo padre, suele propagar el estado a los hijos (al menos para READY / CANCELED), porque si no en KDS se desincroniza
	‚ó¶	recalcula los totales del pedido (para no dejar totales colgados cuando cancelas)
	9	Devuelve el pedido o el item actualizado dentro del wrapper:{ "error": null, "data": { ... }, "message": "OK" }
	10	
Los estados de ITEM que ya vimos en tu API (por KDS y por lo que regresa el GET) son:
	‚Ä¢	NEW
	‚Ä¢	IN_PROGRESS
	‚Ä¢	READY
	‚Ä¢	SERVED
	‚Ä¢	CANCELED
(son los mismos que ya usaste en /api/orders/kds/list).
Vamos a los casos üëá

1. Pasar un item a ‚Äúlo est√° preparando‚Äù (NEW ‚Üí IN_PROGRESS)

{
  "status": "IN_PROGRESS"
}
Se usa cuando cocina ‚Äúagarra‚Äù el ticket.

2. Marcar un item como listo (IN_PROGRESS ‚Üí READY)

{
  "status": "READY"
}
Esto es lo m√°s t√≠pico de KDS: ‚Äúya qued√≥ este plato‚Äù.

3. Servir un item (READY ‚Üí SERVED)

{
  "status": "SERVED"
}
Se usa m√°s en DINE_IN cuando el mesero ya lo llev√≥ a la mesa.

4. Cancelar un item (cualquiera ‚Üí CANCELED)

{
  "status": "CANCELED",
  "reason": "Cliente lo cambi√≥ por otra cosa"
}
Aqu√≠ es donde el repo suele:
	‚Ä¢	marcar el item en CANCELED
	‚Ä¢	volver a calcular el total de la orden (porque un item menos = total menos)

5. Cancelar sin motivo

{
  "status": "CANCELED"
}
V√°lido: el reason era opcional.

6. Volver un item a NEW (p.ej. se equivocaron)

{
  "status": "NEW"
}
Esto lo usan cuando cocina dijo READY pero se dieron cuenta que no estaba.

7. Item que es combo padre ‚Üí marcar READY (propaga)

{
  "status": "READY"
}
Qu√© hace el repo (lo esperado con tu modelo):
	‚Ä¢	pone el padre en READY
	‚Ä¢	pone los childItems en READY tambi√©n
	‚Ä¢	para que en el KDS no te salgan los hijos ‚Äúcolgados‚Äù

8. Item que es combo padre ‚Üí cancelar TODO el combo

{
  "status": "CANCELED",
  "reason": "El cliente cancel√≥ el combo"
}
Lo normal en este dise√±o:
	‚Ä¢	padre ‚Üí CANCELED
	‚Ä¢	hijos ‚Üí CANCELED
	‚Ä¢	recalc ‚Üí baja el total

9. Item que es combo hijo ‚Üí cancelar SOLO ese hijo
Si pegas al itemId del hijo, tambi√©n funciona:

{
  "status": "CANCELED",
  "reason": "Sin papas"
}
	‚Ä¢	ese hijo queda CANCELED
	‚Ä¢	el padre queda como estaba
	‚Ä¢	el total se recalcula

10. Marcar READY algo que ven√≠a de delivery

{
  "status": "READY"
}
Sirve porque en /api/orders/kds/list mostraste delivery tambi√©n.

11. Intentar SERVED directo desde NEW (no recomendado pero posible)

{
  "status": "SERVED"
}
Tu API no hace un ‚Äúworkflow estricto‚Äù aqu√≠, as√≠ que lo va a aceptar; el front debe decidir si lo permite o no.

12. Body vac√≠o ‚Üí error de validaci√≥n

{}
Respuesta esperada:

{
  "error": {
    "code": 400,
    "details": "status is required"
  },
  "data": null,
  "message": "Validation failed"
}

13. Estado no v√°lido ‚Üí error

{
  "status": "DONE"
}
Respuesta:

{
  "error": {
    "code": 400,
    "details": "Invalid enum value for status"
  },
  "data": null,
  "message": "Validation failed"
}

14. Item no existe ‚Üí 404

{
  "status": "READY"
}
‚Üí si el :itemId no existe:

{
  "error": {
    "code": 404,
    "details": null
  },
  "data": null,
  "message": "Order item not found"
}

15. Cancelar item ya SERVED (cocina se equivoc√≥) üëÄ

{
  "status": "CANCELED",
  "reason": "Se sirvi√≥ mal"
}
En tu repositorio este tipo de cambio no est√° bloqueado (el bloqueo fuerte estaba en ‚Äúno cerrar si no est√° pagado‚Äù), as√≠ que lo va a dejar pasar y va a recalcular.

16. Ready con raz√≥n (para cocina)

{
  "status": "READY",
  "reason": "Sin az√∫car, lo pidi√≥ as√≠"
}
Se guarda el status; la raz√≥n puede ir a log o a nota.

Resumen r√°pido
	‚Ä¢	Ruta: PATCH /api/orders/items/:itemId/status
	‚Ä¢	Campos: { "status": "...", "reason"?: "..." }
	‚Ä¢	Estados v√°lidos: NEW, IN_PROGRESS, READY, SERVED, CANCELED
	‚Ä¢	Recalcula: s√≠, el pedido completo
	‚Ä¢	Combos: si tocas el padre, toca a los hijos (READY y CANCELED)
	‚Ä¢	Errores: 400 si no manda status, 404 si no existe item
Con esto ya tienes TODO lo que tu front puede mandar y TODO lo que debe esperar üëå



7.4 Eliminar √≠tem
DELETE /api/orders/items/:itemIdPermiso: orders.update
	‚Ä¢	Elimina el √≠tem
	‚Ä¢	Elimina hijos / modifiers
	‚Ä¢	Recalcula totales
	1	Lee :itemId y lo convierte a n√∫mero.
	2	Llama al repo: orderRepository.deleteItem(itemId).
	3	El repo:
	‚ó¶	busca el item (con parentItemId y childItems)
	‚ó¶	lo borra
	‚ó¶	si el item era combo padre ‚Üí borra tambi√©n los hijos
	‚ó¶	si el item era combo hijo ‚Üí solo borra ese hijo
	‚ó¶	al final llama a recalcTotals del pedido para que los totales queden bien.
	4	Devuelve tu wrapper t√≠pico:{
	5	  "error": null,
	6	  "data": { "deleted": true, "orderId": 45 },
	7	  "message": "OK"
	8	}
	9	(algunas veces regresan el pedido completo; pero en tu proyecto de √≥rdenes casi siempre regresan algo con data + message)

Casos que S√ç tienen sentido
1. Borrar un √≠tem simple

DELETE /api/orders/items/101
Antes el pedido ten√≠a:
	‚Ä¢	item #101 ‚Üí ‚ÄúTorta ahogada‚Äù x2 ‚Üí 13,000
	‚Ä¢	totalCents: 13,000
Despu√©s:

{
  "error": null,
  "data": {
    "deleted": true,
    "orderId": 45
  },
  "message": "OK"
}
y el pedido queda con:
	‚Ä¢	items: []
	‚Ä¢	totalCents: 0
(esto lo hace el recalcTotalsTx)

2. Borrar un √≠tem VARIANTED

DELETE /api/orders/items/205
Ese item ten√≠a:

{
  "id": 205,
  "productId": 25,
  "variantId": 4,
  "quantity": 1
}
‚Üí se va completo, no tienes que mandar la variante. El repo ya sabe cu√°l era.

3. Borrar un √≠tem con modifiers

DELETE /api/orders/items/310
Aunque ese item ten√≠a modifiers asociados, el repo los borra en cascada (porque est√°n relacionados por orderItemId), y luego recalc.Resultado:

{
  "error": null,
  "data": {
    "deleted": true,
    "orderId": 61
  },
  "message": "OK"
}

4. Borrar un combo padre (borra tambi√©n los hijos)

DELETE /api/orders/items/400
Supongamos que el pedido ten√≠a:
	‚Ä¢	item 400 ‚Üí ‚ÄúCombo burger + papas‚Äù (padre)
	‚ó¶	child 401 ‚Üí ‚ÄúHamburguesa sencilla‚Äù
	‚ó¶	child 402 ‚Üí ‚ÄúPapas fritas‚Äù
Al borrar 400 el repo ve que tiene childItems y:
	‚Ä¢	borra 400
	‚Ä¢	borra 401
	‚Ä¢	borra 402
	‚Ä¢	recalcula el pedido
Respuesta:

{
  "error": null,
  "data": {
    "deleted": true,
    "orderId": 90
  },
  "message": "OK"
}
üëâ Esto es importante: no tienes que mandar los IDs de los hijos; el backend ya los conoce porque en tu getById los inclu√≠as con childItems: true.

5. Borrar solo un hijo del combo
S√≠ se puede, si llamas al hijo:

DELETE /api/orders/items/402
	‚Ä¢	No borra al padre
	‚Ä¢	Solo borra ese hijo
	‚Ä¢	Recalcula totales (el combo va a bajar el total de extras si ese hijo ten√≠a)
	‚Ä¢	Te responde igual:{
	‚Ä¢	  "error": null,
	‚Ä¢	  "data": {
	‚Ä¢	    "deleted": true,
	‚Ä¢	    "orderId": 90
	‚Ä¢	  },
	‚Ä¢	  "message": "OK"
	‚Ä¢	  }
	‚Ä¢	
Esto sirve cuando en cocina dijeron ‚Äúel combo sin papas‚Äù.

6. Borrar el √∫ltimo √≠tem del pedido

DELETE /api/orders/items/555
Si era el √∫nico:
	‚Ä¢	el pedido no se borra
	‚Ä¢	solo se queda con items: [] y totales en 0
	‚Ä¢	as√≠ luego le puedes volver a meter items

7. Borrar un √≠tem de un pedido ya en HOLD / OPEN
Es v√°lido, porque el permiso es orders.update y tu proyecto permite editar mientras no est√© CLOSED.

DELETE /api/orders/items/777

8. Intentar borrar un item que no existe ‚Üí 404

DELETE /api/orders/items/999999
Respuesta esperada:

{
  "error": {
    "code": 404,
    "details": null
  },
  "data": null,
  "message": "Order item not found"
}

9. Intentar borrar un √≠tem de un pedido cerrado (si el repo lo protege)
En tu instrucci√≥n de √≥rdenes hab√≠a una regla fuerte para cerrar, no tanto para borrar, pero muchas veces el repo hace:
	‚Ä¢	busca el item
	‚Ä¢	ve que el pedido est√° CLOSED
	‚Ä¢	responde 400
Entonces:

DELETE /api/orders/items/880
Respuesta probable:

{
  "error": {
    "code": 400,
    "details": "Cannot edit items from a closed order"
  },
  "data": null,
  "message": "Order is closed"
}
(esto depende de si en tu repo pusiste el check; lo pongo porque en tu proyecto s√≠ pusiste el check ‚Äúno permitir cerrar si no est√° pagado‚Äù, o sea s√≠ cuidas integridad)

10. Borrar un √≠tem con cantidad alta
No hace falta decir la cantidad; la cantidad est√° en la fila.

DELETE /api/orders/items/620
‚Üí se borra la l√≠nea entera (no ‚Äú1 de 5‚Äù), ese endpoint es de delete line, no de ‚Äúremove 1‚Äù.
Si quisieras ‚Äúbajar de 5 a 4‚Äù, usas:

PATCH /api/orders/items/:itemId
{
  "quantity": 4
}

11. Borrar un √≠tem que ten√≠a extras caros ‚Üí baja totales
Esto es justamente por lo que el repo hace recalc despu√©s del delete.Ejemplo:

DELETE /api/orders/items/701
Ese item ten√≠a:
	‚Ä¢	basePriceCents: 8000
	‚Ä¢	extrasTotalCents: 3000
	‚Ä¢	totalPriceCents: 11000
Al borrarlo:
	‚Ä¢	order.subtotalCents baja 8000
	‚Ä¢	order.totalCents baja 11000
	‚Ä¢	si los pagos ya eran = total, ahora el pedido quedar√° ‚Äúsobrepagado‚Äù ‚Üí ese ajuste suele quedar ya en otro endpoint, pero al menos el order.total ya se corrigi√≥.

Resumen para tu front
	‚Ä¢	Ruta: DELETE /api/orders/items/:itemId
	‚Ä¢	Permiso: orders.update
	‚Ä¢	Qu√© borra: 1 l√≠nea. Si es combo padre ‚Üí borra tambi√©n hijos.
	‚Ä¢	Siempre recalcula: s√≠.
	‚Ä¢	Errores que debes manejar:
	‚ó¶	404 ‚Üí item no existe
	‚ó¶	400 ‚Üí pedido cerrado / no editable
	‚Ä¢	No hay body: es un DELETE puro.
Con esto ya tienes TODOS los casos que tu backend (como lo traes en el zip) puede usar con este endpoint ‚úÖ


10. Notas funcionales clave
	‚Ä¢	Los totales siempre se recalculan ignorando √≠tems cancelados.
	‚Ä¢	Se respetan descuentos / impuestos / service fee ya guardados.
	‚Ä¢	prepEtaMinutes sirve para mostrar ETA en front / kiosko.
	‚Ä¢	source y externalRef diferencian interno vs plataforma.
	‚Ä¢	Con esto el front puede hacer todo el flujo:
	0.	creaci√≥n
	0.	agregar / editar √≠tems
	0.	KDS
	0.	cobros
	0.	cierre
	0.	listado con filtros

11. Glosario para el front
Permisos
	‚Ä¢	orders.read: puede listar y ver
	‚Ä¢	orders.create: puede crear
	‚Ä¢	orders.update: puede editar, pagar, mover estado
serviceType (tipo de servicio)
	‚Ä¢	DINE_IN: consumo en mesa
	‚Ä¢	TAKEAWAY: para llevar
	‚Ä¢	DELIVERY: a domicilio
source (canal)
	‚Ä¢	POS: pedido directo
	‚Ä¢	UBER, DIDI, RAPPI: plataformas externas
status del pedido
	‚Ä¢	DRAFT: borrador, no cocina
	‚Ä¢	OPEN: activo
	‚Ä¢	HOLD: en pausa
	‚Ä¢	CLOSED: cobrado y cerrado
	‚Ä¢	CANCELED: cancelado
OrderItem.status
	‚Ä¢	NEW
	‚Ä¢	IN_PROGRESS
	‚Ä¢	READY
	‚Ä¢	SERVED
	‚Ä¢	CANCELED
Timestamps
	‚Ä¢	acceptedAt: el pedido sali√≥ de borrador / cocina lo tom√≥
	‚Ä¢	readyAt: todos los √≠tems est√°n listos
	‚Ä¢	servedAt: todos servidos o cancelados
	‚Ä¢	closedAt: se cobr√≥
	‚Ä¢	canceledAt: se cancel√≥
Totales (centavos)
	‚Ä¢	subtotalCents: suma de renglones
	‚Ä¢	discountCents: descuentos
	‚Ä¢	serviceFeeCents: propina/fee fijo
	‚Ä¢	taxCents: impuestos
	‚Ä¢	totalCents: subtotal - descuento + service + tax
	‚Ä¢	paymentsTotalCents: suma de pagos
	‚Ä¢	paymentsTipCents: suma de propinas
Pagos (payments[])
	‚Ä¢	method: CASH | CARD | TRANSFER | OTHER
	‚Ä¢	amountCents
	‚Ä¢	tipCents
	‚Ä¢	paidAt
	‚Ä¢	note
Mesa
	‚Ä¢	tableId: id de la mesa
	‚Ä¢	table: { id, name } para mostrar ‚ÄúMesa 12‚Äù
	‚Ä¢	covers: n√∫mero de comensales
DTOs clave
	‚Ä¢	ListOrdersQueryDto: filtros del GET
	‚Ä¢	UpdateOrderMetaDto: para editar nota, mesa, cubiertos, ETA
	‚Ä¢	UpdateOrderStatusDto: para mover el pedido validando pagos
