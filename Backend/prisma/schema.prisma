// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Role {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  users       User[]
    permissions RolePermission[]

}
model Permission {
  id          Int      @id @default(autoincrement())
  code        String   @unique // ej. "users.read"
  name        String?
  description String?
  roles       RolePermission[]
  createdAt   DateTime @default(now())
}

model RolePermission {
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
  @@index([roleId])
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  name          String?
  passwordHash  String
  pinCodeHash   String?             // bcrypt (con salt) ‚Äî para login
  pinCodeDigest String?  @unique    // HMAC determin√≠stico ‚Äî para UNICIDAD
  roleId        Int
  role          Role      @relation(fields: [roleId], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
// üîÅ back-relations
  ordersServed      Order[]    // ‚Üê Order.servedBy
  paymentsReceived  Payment[]  // ‚Üê Payment.receivedBy
  refundsAuthorized OrderRefundLog[] @relation("OrderRefundAdmin")
  @@index([roleId])
}

// ---------------------- NUEVOS PARA MEN√ö/PRODUCTOS ----------------------

// √Årbol de categor√≠as (p. ej. "BEBIDAS" > "FRAPPES")
model Category {
  id        Int        @id @default(autoincrement())
  name      String
  slug      String     @unique
  parentId  Int?
  parent    Category?  @relation("CategoryToParent", fields: [parentId], references: [id])
  children  Category[] @relation("CategoryToParent")

  // back-relations
  products        Product[]
  modifierGroups  ModifierGroup[] @relation("ModifierGroupsByCategory")
  menuSections    MenuSection[]   @relation("CategoryToMenuSections")

  position  Int        @default(0)
  isActive  Boolean    @default(true)
isComboOnly Boolean @default(false)

  @@index([parentId])
}

// Un "producto" puede ser simple, con variantes (tama√±os/sabores),
// o un combo (bundle de otros productos).
enum ProductType {
  SIMPLE
  VARIANTED
  COMBO
}

model Product {
  id            Int              @id @default(autoincrement())
  name          String
  description   String?
  type          ProductType
  categoryId    Int
  category      Category         @relation(fields: [categoryId], references: [id])

  // Para SIMPLE: usar priceCents directamente.
  // Para VARIANTED: dejar priceCents nulo y usar ProductVariant.
  priceCents    Int?
  isActive      Boolean          @default(true)
  sku           String?          @unique

  // ‚¨áÔ∏è NUEVO: almacenar imagen binaria y metadatos
  image         Bytes?
  imageMimeType String?   // "image/jpeg" | "image/png"
  imageSize     Int?      // bytes


  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  isAvailable  Boolean   @default(true)  // ‚Üê DISPONIBLE HOY (independiente de isActive)

  // back-relations
  variants        ProductVariant[]
  modifierGroups  ProductModifierGroup[]
  comboItemsAsCombo     ComboItem[] @relation("ComboItemsAsCombo")
  comboItemsAsComponent ComboItem[] @relation("ComboItemsAsComponent")
  orderItems            OrderItem[] // ‚Üê OrderItem.product

}

// Variantes (p. ej. CH/GDE, 5/10/15 pzas, ‚Äúal panko/capeado‚Äù, ‚Äútostada/litro‚Äù)
model ProductVariant {
  id         Int      @id @default(autoincrement())
  productId  Int
  product    Product  @relation(fields: [productId], references: [id])
  name       String   // ej: "CH", "GDE", "5 pzas", "Litro", "Capeado", "Panko"
  priceCents Int
  sku        String?  @unique
  isActive   Boolean  @default(true)
  position   Int      @default(0)
  isAvailable  Boolean   @default(true)  // ‚Üê DISPONIBLE HOY (independiente de isActive)
  // üîÅ back-relation
  orderItems  OrderItem[] // ‚Üê OrderItem.variant
  modifierGroupLinks ProductVariantModifierGroup[] @relation("VariantModifierGroups")
  comboItems  ComboItem[] @relation("ComboComponentVariant")

  @@index([productId])
  @@unique([productId, name]) // evita duplicados por producto/variante
}

// Grupos de modificadores (ej. ‚ÄúIngredientes dulces‚Äù, ‚ÄúSalsas alitas‚Äù, ‚ÄúAderezos‚Äù)
// con reglas de selecci√≥n (min/max) y si son obligatorios.
model ModifierGroup {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  minSelect   Int      @default(0)
  maxSelect   Int?     // null = sin l√≠mite
  isRequired  Boolean  @default(false)
  isActive    Boolean  @default(true)
  position    Int      @default(0)

  // back-relations
  options      ModifierOption[]
  productLinks ProductModifierGroup[] @relation("ProductToModifierGroup")
  variantLinks ProductVariantModifierGroup[] @relation("GroupVariantLinks")

  // opcional: limitar por categor√≠a (todos los productos de X cat)
  appliesToCategoryId Int?
  appliesToCategory   Category? @relation("ModifierGroupsByCategory", fields: [appliesToCategoryId], references: [id])
}

// Opci√≥n del modificador (ej. ‚ÄúNutella‚Äù, ‚ÄúHershey‚Äôs‚Äù, ‚ÄúIngrediente extra $15‚Äù,
// ‚ÄúBBQ‚Äù, ‚ÄúMango Habanero‚Äù, ‚ÄúRanch‚Äù, etc.) con precio adicional.
model ModifierOption {
  id              Int            @id @default(autoincrement())
  groupId         Int
  group           ModifierGroup  @relation(fields: [groupId], references: [id])
  name            String
  priceExtraCents Int            @default(0)
  isDefault       Boolean        @default(false)
  isActive        Boolean        @default(true)
  position        Int            @default(0)
  // üîÅ back-relation
  orderItemModifiers OrderItemModifier[] // ‚Üê OrderItemModifier.option

  @@index([groupId])
  @@unique([groupId, name])
}

// Asociaci√≥n expl√≠cita de un producto con un grupo de modificadores
// (por si no queremos aplicar s√≥lo por categor√≠a).
model ProductModifierGroup {
  id         Int            @id @default(autoincrement())
  productId  Int
  product    Product        @relation(fields: [productId], references: [id])

  groupId    Int
  group      ModifierGroup  @relation("ProductToModifierGroup", fields: [groupId], references: [id])

  position   Int            @default(0)

  @@unique([productId, groupId])
  @@index([groupId])
}

model ProductVariantModifierGroup {
  id         Int      @id @default(autoincrement())
  variantId  Int
  groupId    Int
  minSelect  Int      @default(0)
  maxSelect  Int?
  isRequired Boolean  @default(false)

  variant ProductVariant @relation("VariantModifierGroups", fields: [variantId], references: [id], onDelete: Cascade)
  group   ModifierGroup  @relation("GroupVariantLinks", fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([variantId, groupId])
  @@index([groupId])
}

// √çtems de combo: definen que un producto (combo) incluye N unidades de otros productos.
model ComboItem {
  id                 Int      @id @default(autoincrement())
  comboProductId     Int
  componentProductId Int
  componentVariantId Int?
  quantity           Int      @default(1)
  isRequired         Boolean  @default(true)
  notes              String?

  comboProduct       Product  @relation("ComboItemsAsCombo", fields: [comboProductId], references: [id])
  componentProduct   Product  @relation("ComboItemsAsComponent", fields: [componentProductId], references: [id])
  componentVariant   ProductVariant? @relation("ComboComponentVariant", fields: [componentVariantId], references: [id], onDelete: SetNull)

  @@index([componentProductId])
  @@index([componentVariantId])
  @@unique([comboProductId, componentProductId, componentVariantId])
}

// Men√∫ y secciones: permite armar diferentes cartas (general y mariscos)
// y ordenar los productos visibles sin alterar categor√≠as internas.
model Menu {
  id        Int          @id @default(autoincrement())
  name      String       @unique
  isActive  Boolean      @default(true)
  publishedAt DateTime?
  version   Int          @default(1)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  deletedAt DateTime?
  sections  MenuSection[]

  @@index([isActive, publishedAt])
}

model MenuSection {
  id        Int       @id @default(autoincrement())
  menuId    Int
  menu      Menu      @relation(fields: [menuId], references: [id], onDelete: Restrict)
  name      String    // p. ej. "CREPAS Y WAFFLES", "BEBIDAS", "MARISCOS"
  position  Int       @default(0)
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // opcional: enlazar una categor√≠a para autolistar
  categoryId Int?
  category   Category? @relation("CategoryToMenuSections", fields: [categoryId], references: [id], onDelete: SetNull)

  items     MenuItem[]

  @@index([menuId, isActive, position])
}

enum MenuItemRefType {
  PRODUCT
  VARIANT
  COMBO
  OPTION
}

model MenuItem {
  id          Int         @id @default(autoincrement())
  sectionId   Int
  section     MenuSection @relation(fields: [sectionId], references: [id], onDelete: Restrict)

  refType     MenuItemRefType
  refId       Int

  displayName       String?
  displayPriceCents Int?
  position          Int       @default(0)
  isFeatured        Boolean   @default(false)
  isActive         Boolean    @default(true)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  deletedAt        DateTime?

  @@index([sectionId, isActive, position])
  @@index([refType, refId])
  @@unique([sectionId, refType, refId, deletedAt])
}




// ========= ENUMS PARA PEDIDOS =========
enum OrderStatus {
  DRAFT      // creado pero a√∫n sin enviar a cocina
  OPEN       // enviado a cocina; puede tener items en preparaci√≥n
  HOLD       // ‚Äúen pausa‚Äù (esperando algo)
  CLOSED     // cobrado/cerrado
  CANCELED   // cancelado
  REFUNDED   // reembolsado posterior al cobro
}

enum ServiceType {
  DINE_IN    // en mesa
  TAKEAWAY   // para llevar
  DELIVERY   // a domicilio (opcional)
}

enum OrderItemStatus {
  NEW
  IN_PROGRESS
  READY
  SERVED
  CANCELED
}

enum PaymentMethod {
  CASH
  CARD
  TRANSFER
  OTHER
}

enum OrderSource {
  POS
  UBER
  DIDI
  RAPPI
}

model ChannelConfig {
  id        Int         @id @default(autoincrement())
  source    OrderSource @unique
  markupPct Decimal     @db.Decimal(5,2)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

// ========= MESAS (opcional, si manejas sal√≥n) =========
model Table {
  id        Int     @id @default(autoincrement())
  name      String  @unique  // ej. "M1", "Barra 2"
  seats     Int?
  isActive  Boolean @default(true)

  orders    Order[]
}

// ========= PEDIDO CABECERA =========
model Order {
  id             Int          @id @default(autoincrement())
  code           String       @unique // folio/ticket, ej. "A-2025-000123"
  status         OrderStatus  @default(OPEN)
  serviceType    ServiceType
  source         OrderSource  @default(POS)

  externalRef    String?
  prepEtaMinutes Int?
  platformMarkupPct Decimal?  @db.Decimal(5,2)

  tableId        Int?
  table          Table?       @relation(fields: [tableId], references: [id], onDelete: SetNull)

  openedAt       DateTime     @default(now())
  acceptedAt     DateTime?
  readyAt        DateTime?
  servedAt       DateTime?
  closedAt       DateTime?
  canceledAt     DateTime?
  refundedAt     DateTime?
  note           String?
  customerName   String?
  customerPhone  String?
  covers         Int?        // # comensales

  servedByUserId Int?
  servedBy       User?       @relation(fields: [servedByUserId], references: [id], onDelete: SetNull)

  // Totales "snapshoteados" para auditor√≠a
  subtotalCents     Int       @default(0)
  discountCents     Int       @default(0)
  serviceFeeCents   Int       @default(0)   // propina/servicio si lo manejas fijo
  taxCents          Int       @default(0)
  totalCents        Int       @default(0)

  items         OrderItem[]
  payments      Payment[]
  refundLogs    OrderRefundLog[]

  @@index([status])
  @@index([serviceType])
  @@index([tableId])
}

// ========= RENGLONES DEL PEDIDO =========
model OrderItem {
  id                 Int            @id @default(autoincrement())
  orderId            Int
  order              Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId          Int
  product            Product        @relation(fields: [productId], references: [id])

  variantId          Int?
  variant            ProductVariant? @relation(fields: [variantId], references: [id], onDelete: SetNull)

  // Para combos: los componentes ser√°n hijos del item padre
  parentItemId       Int?
  parentItem         OrderItem?     @relation("OrderItemToParent", fields: [parentItemId], references: [id], onDelete: Cascade)
  childItems         OrderItem[]    @relation("OrderItemToParent")

  quantity           Int            @default(1)
  status             OrderItemStatus @default(NEW)

  // Precios "snapshoteados" al momento de ordenar (evita que cambie si subes precios)
  basePriceCents     Int            // precio del producto o de la variante (unitario)
  extrasTotalCents   Int            @default(0)
  totalPriceCents    Int            // (base + extras) * quantity

  // Snapshots de nombres (para ticket)
  nameSnapshot       String         // ej. "Frappe Moka"
  variantNameSnapshot String?       // ej. "GDE"

  notes              String?

  modifiers          OrderItemModifier[]

  @@index([orderId])
  @@index([productId])
  @@index([parentItemId])
}

// ========= MODIFICADORES ELEGIDOS POR RENGL√ìN =========
model OrderItemModifier {
  id               Int             @id @default(autoincrement())
  orderItemId      Int
  orderItem        OrderItem       @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  optionId         Int
  option           ModifierOption  @relation(fields: [optionId], references: [id])

  quantity         Int             @default(1)
  priceExtraCents  Int             @default(0) // snapshot del extra en ese momento
  nameSnapshot     String          // ej. "BBQ"

  @@index([orderItemId])
  @@index([optionId])
}

// ========= PAGOS =========
model Payment {
  id               Int            @id @default(autoincrement())
  orderId          Int
  order            Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)

  method           PaymentMethod
  amountCents      Int
  tipCents         Int            @default(0)
  receivedAmountCents Int?
  changeCents      Int?
  paidAt           DateTime       @default(now())

  receivedByUserId Int?
  receivedBy       User?          @relation(fields: [receivedByUserId], references: [id], onDelete: SetNull)

  note             String?

  @@index([orderId])
  @@index([method])
}

model OrderRefundLog {
  id           Int      @id @default(autoincrement())
  orderId      Int
  order        Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  adminUserId  Int
  adminUser    User     @relation("OrderRefundAdmin", fields: [adminUserId], references: [id])
  amountCents  Int
  tipCents     Int      @default(0)
  reason       String?
  createdAt    DateTime @default(now())

  @@index([orderId])
  @@index([adminUserId])
}
