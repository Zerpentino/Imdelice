8. Pagos
POST /api/orders/:id/paymentsPermiso: orders.updateBody: AddPaymentDto
	‚Ä¢	Registra pago + propina
	‚Ä¢	Revisa el acumulado
	‚Ä¢	Si ya cubre el total ‚Üí cierra autom√°ticamente el pedido
DTO exacto (de tu zip)

export const AddPaymentDto = z.object({
  method: z.enum(["CASH", "CARD", "TRANSFER", "OTHER"]),
  amountCents: z.number().int().nonnegative(),
  tipCents: z.number().int().nonnegative().default(0),
  note: z.string().optional()
});
Traducci√≥n:
	‚Ä¢	method ‚Üí obligatorio ‚Üí CASH | CARD | TRANSFER | OTHER
	‚Ä¢	amountCents ‚Üí obligatorio ‚Üí entero ‚â• 0 (en centavos)
	‚Ä¢	tipCents ‚Üí opcional ‚Üí entero ‚â• 0 (default 0)
	‚Ä¢	note ‚Üí opcional

Qu√© hace el repo (esto es lo chido)
En PrismaOrderRepository.addPayment(...) hace:
	1	Crea el pago:
	‚ó¶	orderId: el que viene en la ruta
	‚ó¶	method: el que mandaste
	‚ó¶	amountCents
	‚ó¶	tipCents (o 0)
	‚ó¶	receivedByUserId: el user que sac√≥ del token
	‚ó¶	note
	2	Luego agrega todos los pagos de la orden:const agg = await tx.payment.aggregate({
	3	  where: { orderId },
	4	  _sum: { amountCents: true, tipCents: true },
	5	});
	6	const ord = await tx.order.findUnique({ where: { id: orderId } });
	7	const paid = (agg._sum.amountCents || 0) + (agg._sum.tipCents || 0);
	8	if (ord && paid >= (ord.totalCents || 0)) {
	9	  await tx.order.update({
	10	    where: { id: orderId },
	11	    data: { status: "CLOSED", closedAt: new Date() },
	12	  });
	13	}
	14	üî¥ Eso significa: si con este pago ya alcanzaste o superaste el total, la orden se cierra sola (status: "CLOSED").
	15	Te regresa el pago que cre√≥.

Respuesta t√≠pica

{
  "error": null,
  "data": {
    "id": 25,
    "orderId": 70,
    "method": "CASH",
    "amountCents": 20000,
    "tipCents": 0,
    "paidAt": "2025-10-30T18:20:00.000Z",
    "receivedByUserId": 1,
    "note": null
  },
  "message": "Paid"
}
status HTTP: 201
Ojo: NO te devuelve la orden; te devuelve el pago. Si el front quiere ver que se cerr√≥, hace luego GET /api/orders/:id.

TODOS los casos que puedes mandar üí∞
1. Pago en efectivo (simple)

{
  "method": "CASH",
  "amountCents": 15000
}
	‚Ä¢	tip = 0
	‚Ä¢	si el total de la orden ‚â§ 150.00 ‚Üí la cierra

2. Pago con propina

{
  "method": "CASH",
  "amountCents": 15000,
  "tipCents": 2000
}
Aqu√≠ el repo suma amountCents + tipCents para ver si cierra.O sea, si la orden costaba 17,000 ‚Üí con esto la cierra.

3. Pago con tarjeta

{
  "method": "CARD",
  "amountCents": 23000
}
Sirve igual. El m√©todo solo se guarda.

4. Pago por transferencia con nota

{
  "method": "TRANSFER",
  "amountCents": 12000,
  "note": "Transferencia BBVA ref 123"
}

5. Pago ‚Äúotro‚Äù (vales, etc.)

{
  "method": "OTHER",
  "amountCents": 5000,
  "note": "Vale restaurante"
}

6. Pago parcial (para luego complementar)

{
  "method": "CASH",
  "amountCents": 10000
}
	‚Ä¢	Si el pedido era de 23,000 ‚Üí NO la cierra
	‚Ä¢	El front puede mostrar: pagado 100.00 / total 230.00
	‚Ä¢	Luego mandas otro pago (ver caso 7)

7. Segundo pago que completa la orden
1er pago:

{
  "method": "CASH",
  "amountCents": 10000
}
2do pago:

{
  "method": "CARD",
  "amountCents": 13000
}
	‚Ä¢	El 2do pago hace que paid >= totalCents ‚Üí el repo cierra la orden.

8. Pago que supera el total (pago ‚Äúde m√°s‚Äù)

{
  "method": "CASH",
  "amountCents": 30000
}
Si la orden era 23,000:
	‚Ä¢	paid = 30,000
	‚Ä¢	30,000 ‚â• 23,000 ‚Üí se cierra
	‚Ä¢	NO hace cambio, solo guarda el pago as√≠

9. Pago solo de propina (amount 0, tip > 0)
Como tu DTO permite amountCents = 0 y tipCents ‚â• 0:

{
  "method": "CASH",
  "amountCents": 0,
  "tipCents": 500
}
	‚Ä¢	Guarda el pago
	‚Ä¢	Suma 500 al ‚Äúpaid‚Äù
	‚Ä¢	Si con eso alcanza ‚Üí cierra (raro, pero posible)

10. Pago en 0 total (para probar validaci√≥n)

{
  "method": "CASH",
  "amountCents": 0
}
Lo acepta porque es nonnegative().No va a cerrar a menos que la orden sea 0.

11. Pago con nota larga

{
  "method": "CARD",
  "amountCents": 8000,
  "note": "Pag√≥ con tarjeta f√≠sica, aprobaron en terminal"
}

12. Intentar pagar sin method ‚Üí 400

{
  "amountCents": 10000
}
Respuesta:

{
  "error": {
    "code": 500,
    "details": {}
  },
  "data": null,
  "message": "Error adding payment"
}
(el 500 te lo da porque Zod lanz√≥ error y tu controller lo est√° mapeando a 500 salvo que sea ‚ÄúId inv√°lido‚Äù; si quieres 400 aqu√≠, hay que ajustar el controller)

13. Intentar pagar sin auth ‚Üí 401
Porque el controller hace:

if (!receivedByUserId) return fail(res, "Unauthorized", 401);
Respuesta:

{
  "error": {
    "code": 401,
    "details": null
  },
  "data": null,
  "message": "Unauthorized"
}

14. Intentar pagar una orden que NO existe ‚Üí 500 (desde repo)

{
  "method": "CASH",
  "amountCents": 10000
}
si el :id no existe, Prisma truena dentro de la tx ‚Üí el controller responde:

{
  "error": {
    "code": 500,
    "details": {}
  },
  "data": null,
  "message": "Error adding payment"
}
(si quieres 404, hay que envolver el create y checar existencia antes)

15. Pagar una orden que ya estaba CLOSED
Tu repo no bloquea el create de pago si ya est√° CLOSED: lo que hace es crear el pago y volver a checar.O sea, esto va a funcionar igual:

{
  "method": "CASH",
  "amountCents": 1000
}
pero la orden seguir√° CLOSED.

Cosas importantes para tu front
	1	Siempre manda method y amountCents.
	2	El usuario autenticado es el que se guarda en receivedByUserId (no lo mandes t√∫).
	3	Despu√©s de pagar, si quieres ver que la orden se cerr√≥, haz:GET /api/orders/:id
	4	porque el POST te regresa solo el pago.
	5	Los montos son en centavos.
	6	Si quieres ‚Äúpago mixto‚Äù, solo llamas varias veces a este endpoint.


10. Notas funcionales clave
	‚Ä¢	Los totales siempre se recalculan ignorando √≠tems cancelados.
	‚Ä¢	Se respetan descuentos / impuestos / service fee ya guardados.
	‚Ä¢	prepEtaMinutes sirve para mostrar ETA en front / kiosko.
	‚Ä¢	source y externalRef diferencian interno vs plataforma.
	‚Ä¢	Con esto el front puede hacer todo el flujo:
	0.	creaci√≥n
	0.	agregar / editar √≠tems
	0.	KDS
	0.	cobros
	0.	cierre
	0.	listado con filtros

11. Glosario para el front
Permisos
	‚Ä¢	orders.read: puede listar y ver
	‚Ä¢	orders.create: puede crear
	‚Ä¢	orders.update: puede editar, pagar, mover estado
serviceType (tipo de servicio)
	‚Ä¢	DINE_IN: consumo en mesa
	‚Ä¢	TAKEAWAY: para llevar
	‚Ä¢	DELIVERY: a domicilio
source (canal)
	‚Ä¢	POS: pedido directo
	‚Ä¢	UBER, DIDI, RAPPI: plataformas externas
status del pedido
	‚Ä¢	DRAFT: borrador, no cocina
	‚Ä¢	OPEN: activo
	‚Ä¢	HOLD: en pausa
	‚Ä¢	CLOSED: cobrado y cerrado
	‚Ä¢	CANCELED: cancelado
OrderItem.status
	‚Ä¢	NEW
	‚Ä¢	IN_PROGRESS
	‚Ä¢	READY
	‚Ä¢	SERVED
	‚Ä¢	CANCELED
Timestamps
	‚Ä¢	acceptedAt: el pedido sali√≥ de borrador / cocina lo tom√≥
	‚Ä¢	readyAt: todos los √≠tems est√°n listos
	‚Ä¢	servedAt: todos servidos o cancelados
	‚Ä¢	closedAt: se cobr√≥
	‚Ä¢	canceledAt: se cancel√≥
Totales (centavos)
	‚Ä¢	subtotalCents: suma de renglones
	‚Ä¢	discountCents: descuentos
	‚Ä¢	serviceFeeCents: propina/fee fijo
	‚Ä¢	taxCents: impuestos
	‚Ä¢	totalCents: subtotal - descuento + service + tax
	‚Ä¢	paymentsTotalCents: suma de pagos
	‚Ä¢	paymentsTipCents: suma de propinas
Pagos (payments[])
	‚Ä¢	method: CASH | CARD | TRANSFER | OTHER
	‚Ä¢	amountCents
	‚Ä¢	tipCents
	‚Ä¢	paidAt
	‚Ä¢	note
Mesa
	‚Ä¢	tableId: id de la mesa
	‚Ä¢	table: { id, name } para mostrar ‚ÄúMesa 12‚Äù
	‚Ä¢	covers: n√∫mero de comensales
DTOs clave
	‚Ä¢	ListOrdersQueryDto: filtros del GET
	‚Ä¢	UpdateOrderMetaDto: para editar nota, mesa, cubiertos, ETA
	‚Ä¢	UpdateOrderStatusDto: para mover el pedido validando pagos

